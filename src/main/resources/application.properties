spring.jpa.show-sql=true
#spring.datasource.url = jdbc:h2:mem:
#spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver
#spring.datasource.username=sa
#spring.datasource.password=sa

logging.pattern.console=%clr(%d{HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:%4p}) [%15.15t] <%X{reqId}> %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n


#server.tomcat.threads.max=500

# tocmai ai alocat + 300 thread x 250KB de stack


# tocmai am pierdut 300 MB de memorie cand am marit numarul max de thread de la 200(default) la 500. de unde ?
# fiecare thread costa 1 MB = STACKul threadului
#server.tomcat.threads.max=500
# inseamca cu programarea clasica blocanta sync din java <19 poti duce simultan
# 500 de requesturi paralele in acelasi timp

# asta se poate intampla daca:
# - ai MULTI useri simultan (api calluri multe/sec)  eg 10.000 req/sec dar un req il rezolvi in 20 ms
#       50/sec cu 1 thread x 500 = 25000 de req
# + requesturi care dureaza timp

#thread pool starvation = ai ramas fara threaduri in pool.