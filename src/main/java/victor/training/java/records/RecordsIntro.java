package victor.training.java.records;

import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import jakarta.validation.constraints.Min;
import lombok.Value;

public class RecordsIntro {
  public static void main(String[] args) {
    Point point = Point.from("1","2");
    System.out.println(point.x()); // SHOCK! no get- prefix
    validateAnnotations(point);

    // we can now see codebases that removed get- from ALL their getters
    System.out.println(point);
  }

  private static void validateAnnotations(Point point) {
    // apply validations on the instance
    ValidatorFactory factory = jakarta.validation.Validation.buildDefaultValidatorFactory();
    Validator validator = factory.getValidator();
    validator.validate(point).forEach(System.out::println);
  }
}
// .class file contains extra bytecode generated by lombok annotation processor
//@Data // getters, setters, hashcode/equals, toString = perfect for CRUD systems
//@Value // getters, ctor, all fields=private+final, hashcode/equals, toString

class A {}
record Point(@Min(0) int x, @Min(0) int y) /*extends A*/{
  public Point{
    if (x < 0 || y < 0) { // scary! objects refuse to instantiate if invalid
      throw new IllegalArgumentException("Negative coordinates");
    }
  }
  public Point(String xs, String ys) {
    int xx = Integer.parseInt(xs);// java 22
    this(xx, Integer.parseInt(ys));
  }
  public static Point from(String xs, String ys) {// better than constructors on records?
    int xx = Integer.parseInt(xs);
    int yy = Integer.parseInt(ys);
    return new Point(xx, yy);
  }
  public String toString() {
    return x + "," + y;
  }
  public int x() {
    return x;
  }
}


//record Point3D extends Point {}

// let's play.
